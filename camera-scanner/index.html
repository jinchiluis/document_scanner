<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Document Scanner Demo</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #f5f5f5; margin: 0; padding: 24px; text-align: center; }
    #camera-container { position: relative; display: inline-block; background: #111; border-radius: 12px; }
    video, canvas { max-width: 90vw; border-radius: 12px; }
    #overlay { position: absolute; top: 0; left: 0; pointer-events: none; }
    #controls { margin: 16px 0; }
    button { font-size: 1rem; padding: 12px 28px; border-radius: 7px; border: none; background: #007bff; color: #fff; cursor: pointer; margin: 0 5px; }
    button:disabled { background: #aaa; }
    button.secondary { background: #6c757d; }
    button.success { background: #28a745; }
    .status { margin: 18px auto; padding: 12px; border-radius: 8px; max-width: 320px; }
    .status.success { background: #e8ffe8; color: #228c22; }
    .status.error { background: #ffeaea; color: #d60000; }
    .status.info { background: #e8f4ff; color: #0066cc; }
    .slider-group { margin: 14px 0; }
    .slider-group label { font-size: 0.95em; margin-right: 12px; }
    #preview { margin: 28px auto; max-width: 320px; display: none; }
    #preview img { width: 100%; border-radius: 8px; border: 2px solid #333; }
    #detection-label { position: absolute; top: 10px; left: 10px; padding: 5px 14px; border-radius: 5px; background: rgba(0,0,0,0.7); color: #fff; font-size: 1em;}
    #detection-label.detected { background: rgba(33,200,70,0.88); }
    #page-counter { position: absolute; top: 10px; right: 10px; padding: 5px 14px; border-radius: 5px; background: rgba(0,0,0,0.7); color: #fff; font-size: 1em; display: none; }
    #page-counter.visible { display: block; background: rgba(255,165,0,0.88); }
    #action-buttons { display: none; margin-top: 20px; }
    #action-buttons.visible { display: block; }
    .page-thumbnails { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
    .page-thumb { width: 80px; height: 100px; border: 2px solid #ccc; border-radius: 4px; object-fit: cover; cursor: pointer; }
    .page-thumb:hover { border-color: #007bff; }
    #debug-info { position: absolute; bottom: 10px; left: 10px; padding: 5px 10px; border-radius: 5px; background: rgba(0,0,0,0.7); color: #fff; font-size: 0.8em; }
    .manual-mode { background: #ff6b6b !important; }
    .corner-marker { position: absolute; width: 40px; height: 40px; border: 3px solid #2ef516; border-radius: 50%; background: rgba(46, 245, 22, 0.3); transform: translate(-50%, -50%); cursor: move; touch-action: none; }
    .corner-marker.dragging { background: rgba(255, 107, 107, 0.5); border-color: #ff6b6b; }
    #manual-instruction { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0,0,0,0.8); color: #fff; border-radius: 5px; display: none; }
  </style>
</head>
<body>
  <h1>ðŸ“„ Document Scanner Demo</h1>
  <div id="camera-container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div id="detection-label">Searchingâ€¦</div>
    <div id="page-counter">Pages: 0</div>
    <div id="debug-info">Initializing...</div>
    <div id="manual-instruction">Drag corners to adjust document boundaries</div>
  </div>
  <div id="controls">
    <button id="capture-btn" disabled>Initializingâ€¦</button>
    <button id="toggle-btn">Auto Detect: ON</button>
    <button id="manual-btn" class="secondary">Manual Mode</button>
  </div>
  <div class="slider-group">
    <label>Edge Sensitivity <span id="edge-value">50</span></label>
    <input type="range" id="edge-slider" min="10" max="100" value="50" />
    <label>Min Area <span id="area-value">20</span>%</label>
    <input type="range" id="area-slider" min="5" max="50" value="20" />
  </div>
  <div id="status" class="status"></div>
  <div id="preview">
    <h3>ðŸ“‘ Last Captured Page:</h3>
    <img id="preview-img" src="" />
  </div>
  <div id="action-buttons">
    <button id="continue-btn" class="secondary">ðŸ“„ Continue Scanning</button>
    <button id="retake-btn" class="secondary">ðŸ”„ Retake Last Page</button>
    <button id="save-btn" class="success">ðŸ’¾ Save as PDF</button>
  </div>
  <div class="page-thumbnails" id="page-thumbs"></div>
  <canvas id="hidden-canvas" style="display:none;"></canvas>
  <canvas id="edge-canvas" style="display:none;"></canvas>
  <script>
    // === Globals ===
    let video = document.getElementById('video');
    let overlay = document.getElementById('overlay');
    let overlayCtx = overlay.getContext('2d');
    let hiddenCanvas = document.getElementById('hidden-canvas');
    let hiddenCtx = hiddenCanvas.getContext('2d');
    let edgeCanvas = document.getElementById('edge-canvas');
    let edgeCtx = edgeCanvas.getContext('2d');
    let autoDetect = true;
    let manualMode = false;
    let lastCorners = null;
    let lastDetection = 0;
    let isProcessing = false;
    let edgeThreshold = 50;
    let minAreaPct = 20;
    
    // Manual mode corners
    let manualCorners = null;
    let draggedCorner = null;
    
    // Multi-page buffer
    let pageBuffer = [];
    let currentPageData = null;

    // === UI Hooks ===
    let captureBtn = document.getElementById('capture-btn');
    let toggleBtn = document.getElementById('toggle-btn');
    let manualBtn = document.getElementById('manual-btn');
    let edgeSlider = document.getElementById('edge-slider');
    let areaSlider = document.getElementById('area-slider');
    let statusBox = document.getElementById('status');
    let detectionLabel = document.getElementById('detection-label');
    let preview = document.getElementById('preview');
    let previewImg = document.getElementById('preview-img');
    let pageCounter = document.getElementById('page-counter');
    let actionButtons = document.getElementById('action-buttons');
    let continueBtn = document.getElementById('continue-btn');
    let retakeBtn = document.getElementById('retake-btn');
    let saveBtn = document.getElementById('save-btn');
    let pageThumbs = document.getElementById('page-thumbs');
    let debugInfo = document.getElementById('debug-info');
    let manualInstruction = document.getElementById('manual-instruction');

    edgeSlider.oninput = e => {
      edgeThreshold = +e.target.value;
      document.getElementById('edge-value').textContent = edgeThreshold;
    };
    areaSlider.oninput = e => {
      minAreaPct = +e.target.value;
      document.getElementById('area-value').textContent = minAreaPct;
    };

    toggleBtn.onclick = () => {
      autoDetect = !autoDetect;
      toggleBtn.textContent = 'Auto Detect: ' + (autoDetect ? 'ON' : 'OFF');
      if (autoDetect && !manualMode) requestAnimationFrame(detectFrame);
    };
    
    manualBtn.onclick = () => {
      manualMode = !manualMode;
      manualBtn.classList.toggle('manual-mode');
      manualBtn.textContent = manualMode ? 'Exit Manual' : 'Manual Mode';
      
      if (manualMode) {
        initManualMode();
        detectionLabel.textContent = 'Manual Mode';
        detectionLabel.classList.add('detected');
        manualInstruction.style.display = 'block';
      } else {
        clearManualMode();
        detectionLabel.textContent = 'Searching...';
        detectionLabel.classList.remove('detected');
        manualInstruction.style.display = 'none';
        if (autoDetect) requestAnimationFrame(detectFrame);
      }
    };

    captureBtn.onclick = () => captureDocument();
    
    continueBtn.onclick = () => {
      if (currentPageData) {
        pageBuffer.push(currentPageData);
        updatePageDisplay();
        currentPageData = null;
        preview.style.display = 'none';
        actionButtons.classList.remove('visible');
        showStatus(`Page ${pageBuffer.length} added. Continue scanning...`, 'info');
      }
    };
    
    retakeBtn.onclick = () => {
      currentPageData = null;
      preview.style.display = 'none';
      actionButtons.classList.remove('visible');
      showStatus('Page discarded. Ready to retake.', 'info');
    };
    
    saveBtn.onclick = async () => {
      if (currentPageData) {
        pageBuffer.push(currentPageData);
      }
      if (pageBuffer.length === 0) {
        showStatus('No pages to save!', 'error');
        return;
      }
      
      showStatus(`Saving ${pageBuffer.length} page(s) as PDF...`, 'info');
      
      // For demo purposes, just download the images
      // In real implementation, this would send to server
      pageBuffer.forEach((page, idx) => {
        const link = document.createElement('a');
        link.download = `page_${idx + 1}.jpg`;
        link.href = page;
        link.click();
      });
      
      showStatus(`Downloaded ${pageBuffer.length} page(s)!`, 'success');
      
      // Clear buffer and reset UI
      pageBuffer = [];
      currentPageData = null;
      updatePageDisplay();
      preview.style.display = 'none';
      actionButtons.classList.remove('visible');
    };

    function updatePageDisplay() {
      pageCounter.textContent = `Pages: ${pageBuffer.length}`;
      pageCounter.classList.toggle('visible', pageBuffer.length > 0);
      
      // Update thumbnails
      pageThumbs.innerHTML = '';
      pageBuffer.forEach((page, idx) => {
        const thumb = document.createElement('img');
        thumb.src = page;
        thumb.className = 'page-thumb';
        thumb.title = `Page ${idx + 1}`;
        thumb.onclick = () => {
          previewImg.src = page;
          preview.style.display = 'block';
        };
        pageThumbs.appendChild(thumb);
      });
    }

    // === Camera setup ===
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720} }
        });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          setCanvasSize();
          captureBtn.disabled = false;
          captureBtn.textContent = 'ðŸ“¸ Capture';
          showStatus('Camera ready!','success');
          debugInfo.textContent = 'Camera active';
          if (autoDetect && !manualMode) requestAnimationFrame(detectFrame);
        };
      } catch (err) {
        showStatus('Camera error: ' + err.message, 'error');
        captureBtn.textContent = 'Camera Failed';
        debugInfo.textContent = 'Camera failed';
      }
    }
    
    function setCanvasSize() {
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      hiddenCanvas.width = video.videoWidth;
      hiddenCanvas.height = video.videoHeight;
      edgeCanvas.width = video.videoWidth;
      edgeCanvas.height = video.videoHeight;
      console.log(`Canvas size set: ${video.videoWidth}x${video.videoHeight}`);
    }

    // === Simple Edge Detection (no OpenCV) ===
    function detectEdges(imageData) {
      const width = imageData.width;
      const height = imageData.height;
      const data = imageData.data;
      const output = new Uint8ClampedArray(data.length);
      
      // Convert to grayscale and apply simple Sobel edge detection
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          
          // Get surrounding pixels for Sobel
          const tl = ((y-1) * width + (x-1)) * 4;
          const tm = ((y-1) * width + x) * 4;
          const tr = ((y-1) * width + (x+1)) * 4;
          const ml = (y * width + (x-1)) * 4;
          const mr = (y * width + (x+1)) * 4;
          const bl = ((y+1) * width + (x-1)) * 4;
          const bm = ((y+1) * width + x) * 4;
          const br = ((y+1) * width + (x+1)) * 4;
          
          // Grayscale values
          const gray = p => data[p] * 0.299 + data[p+1] * 0.587 + data[p+2] * 0.114;
          
          // Sobel X
          const sobelX = -gray(tl) - 2*gray(ml) - gray(bl) + gray(tr) + 2*gray(mr) + gray(br);
          // Sobel Y
          const sobelY = -gray(tl) - 2*gray(tm) - gray(tr) + gray(bl) + 2*gray(bm) + gray(br);
          
          const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
          const edge = magnitude > edgeThreshold ? 255 : 0;
          
          output[idx] = edge;
          output[idx + 1] = edge;
          output[idx + 2] = edge;
          output[idx + 3] = 255;
        }
      }
      
      return new ImageData(output, width, height);
    }

    // === Simple Rectangle Detection ===
    function findDocumentCorners(edgeData) {
      const width = edgeData.width;
      const height = edgeData.height;
      const data = edgeData.data;
      
      // Find edge points
      const edgePoints = [];
      for (let y = 0; y < height; y += 5) { // Sample every 5 pixels for performance
        for (let x = 0; x < width; x += 5) {
          const idx = (y * width + x) * 4;
          if (data[idx] > 128) {
            edgePoints.push([x, y]);
          }
        }
      }
      
      if (edgePoints.length < 100) return null;
      
      // Simple heuristic: find extreme points that might form a rectangle
      let minX = width, maxX = 0, minY = height, maxY = 0;
      let topLeftish = null, topRightish = null, bottomLeftish = null, bottomRightish = null;
      let maxDist = 0;
      
      for (const [x, y] of edgePoints) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      
      // Check if the potential rectangle is large enough
      const rectWidth = maxX - minX;
      const rectHeight = maxY - minY;
      const rectArea = rectWidth * rectHeight;
      const minArea = width * height * minAreaPct / 100;
      
      if (rectArea < minArea) return null;
      
      // Find corner candidates in each quadrant
      const midX = (minX + maxX) / 2;
      const midY = (minY + maxY) / 2;
      
      let corners = {
        tl: null, tr: null, bl: null, br: null
      };
      let distances = {
        tl: 0, tr: 0, bl: 0, br: 0
      };
      
      for (const [x, y] of edgePoints) {
        // Top-left quadrant
        if (x < midX && y < midY) {
          const dist = Math.sqrt((x - minX)**2 + (y - minY)**2);
          if (!corners.tl || dist < distances.tl) {
            corners.tl = [x, y];
            distances.tl = dist;
          }
        }
        // Top-right quadrant
        else if (x >= midX && y < midY) {
          const dist = Math.sqrt((x - maxX)**2 + (y - minY)**2);
          if (!corners.tr || dist < distances.tr) {
            corners.tr = [x, y];
            distances.tr = dist;
          }
        }
        // Bottom-left quadrant
        else if (x < midX && y >= midY) {
          const dist = Math.sqrt((x - minX)**2 + (y - maxY)**2);
          if (!corners.bl || dist < distances.bl) {
            corners.bl = [x, y];
            distances.bl = dist;
          }
        }
        // Bottom-right quadrant
        else if (x >= midX && y >= midY) {
          const dist = Math.sqrt((x - maxX)**2 + (y - maxY)**2);
          if (!corners.br || dist < distances.br) {
            corners.br = [x, y];
            distances.br = dist;
          }
        }
      }
      
      // Check if we found all corners
      if (!corners.tl || !corners.tr || !corners.bl || !corners.br) {
        return null;
      }
      
      return [corners.tl, corners.tr, corners.br, corners.bl];
    }

    // === Document Detection Loop ===
    function detectFrame() {
      if (!autoDetect || isProcessing || video.readyState !== 4 || manualMode) {
        if (autoDetect && !manualMode) requestAnimationFrame(detectFrame);
        return;
      }
      
      try {
        // Get video frame
        hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
        const frame = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
        
        // Simple edge detection
        const edges = detectEdges(frame);
        
        // Find document
        const corners = findDocumentCorners(edges);
        
        // Draw overlay
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
        const now = Date.now();
        
        if (corners) {
          lastCorners = corners;
          lastDetection = now;
          debugInfo.textContent = 'Document found!';
        }
        
        // Draw if recent detection
        if (lastCorners && (now - lastDetection < 700)) {
          drawPolygon(lastCorners, "#2ef516");
          detectionLabel.textContent = 'Document Detected!';
          detectionLabel.classList.add('detected');
        } else {
          detectionLabel.textContent = 'Searchingâ€¦';
          detectionLabel.classList.remove('detected');
          lastCorners = null;
          debugInfo.textContent = 'No document detected';
        }
        
      } catch (error) {
        console.error('Detection error:', error);
        debugInfo.textContent = 'Detection error: ' + error.message;
      }
      
      requestAnimationFrame(detectFrame);
    }
    
    // === Manual Mode ===
    function initManualMode() {
      const w = overlay.width;
      const h = overlay.height;
      
      // Default corners at 20% margins
      manualCorners = [
        [w * 0.2, h * 0.2],
        [w * 0.8, h * 0.2],
        [w * 0.8, h * 0.8],
        [w * 0.2, h * 0.8]
      ];
      
      lastCorners = manualCorners;
      drawManualOverlay();
      setupCornerDragging();
    }
    
    function clearManualMode() {
      // Remove corner markers
      document.querySelectorAll('.corner-marker').forEach(m => m.remove());
      overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
      lastCorners = null;
      manualCorners = null;
    }
    
    function drawManualOverlay() {
      overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
      if (manualCorners) {
        drawPolygon(manualCorners, "#2ef516");
      }
    }
    
    function setupCornerDragging() {
      // Remove existing markers
      document.querySelectorAll('.corner-marker').forEach(m => m.remove());
      
      manualCorners.forEach((corner, idx) => {
        const marker = document.createElement('div');
        marker.className = 'corner-marker';
        marker.style.left = corner[0] + 'px';
        marker.style.top = corner[1] + 'px';
        marker.dataset.cornerIndex = idx;
        
        // Mouse events
        marker.addEventListener('mousedown', startDragging);
        // Touch events
        marker.addEventListener('touchstart', startDragging);
        
        document.getElementById('camera-container').appendChild(marker);
      });
    }
    
    function startDragging(e) {
      e.preventDefault();
      const marker = e.target;
      marker.classList.add('dragging');
      draggedCorner = parseInt(marker.dataset.cornerIndex);
      
      const moveHandler = (e) => {
        const rect = overlay.getBoundingClientRect();
        let x, y;
        
        if (e.touches) {
          x = e.touches[0].clientX - rect.left;
          y = e.touches[0].clientY - rect.top;
        } else {
          x = e.clientX - rect.left;
          y = e.clientY - rect.top;
        }
        
        // Constrain to canvas bounds
        x = Math.max(0, Math.min(overlay.width, x));
        y = Math.max(0, Math.min(overlay.height, y));
        
        manualCorners[draggedCorner] = [x, y];
        marker.style.left = x + 'px';
        marker.style.top = y + 'px';
        
        lastCorners = manualCorners;
        drawManualOverlay();
      };
      
      const endHandler = () => {
        marker.classList.remove('dragging');
        draggedCorner = null;
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', endHandler);
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('touchend', endHandler);
      };
      
      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', endHandler);
      document.addEventListener('touchmove', moveHandler);
      document.addEventListener('touchend', endHandler);
    }
    
    // Draw detected polygon/corners
    function drawPolygon(corners, color) {
      overlayCtx.strokeStyle = color;
      overlayCtx.lineWidth = 4;
      overlayCtx.beginPath();
      overlayCtx.moveTo(corners[0][0], corners[0][1]);
      for (let i = 1; i < 4; ++i) overlayCtx.lineTo(corners[i][0], corners[i][1]);
      overlayCtx.closePath();
      overlayCtx.stroke();
      
      // Draw corner circles
      for (let c of corners) {
        overlayCtx.beginPath();
        overlayCtx.arc(c[0], c[1], 8, 0, 2 * Math.PI);
        overlayCtx.fillStyle = color;
        overlayCtx.fill();
      }
    }

    // === Capture, Perspective Transform, Save ===
    function captureDocument() {
      if (isProcessing) return;
      isProcessing = true;
      let imgData;
      
      if (lastCorners) {
        imgData = extractDocument(lastCorners);
        showStatus('Document transformed!', 'success');
      } else {
        hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
        imgData = hiddenCanvas.toDataURL('image/jpeg', 0.95);
        showStatus('Full frame captured!', 'success');
      }
      
      currentPageData = imgData;
      preview.style.display = 'block';
      previewImg.src = imgData;
      actionButtons.classList.add('visible');
      isProcessing = false;
    }
    
    function extractDocument(corners) {
      // Calculate output dimensions
      const w = Math.max(
        dist(corners[0], corners[1]),
        dist(corners[2], corners[3])
      );
      const h = Math.max(
        dist(corners[0], corners[3]),
        dist(corners[1], corners[2])
      );
      
      // Create output canvas
      const outCanvas = document.createElement('canvas');
      outCanvas.width = w;
      outCanvas.height = h;
      const outCtx = outCanvas.getContext('2d');
      
      // Get source image
      hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
      
      // For simple implementation without OpenCV, we'll use a basic approach
      // This won't do true perspective correction but will work for roughly aligned documents
      
      // Draw using canvas transform (simplified)
      outCtx.save();
      
      // This is a simplified version - for true perspective transform you'd need more complex math
      // For now, just crop to the bounding box of the corners
      const minX = Math.min(...corners.map(c => c[0]));
      const minY = Math.min(...corners.map(c => c[1]));
      const maxX = Math.max(...corners.map(c => c[0]));
      const maxY = Math.max(...corners.map(c => c[1]));
      
      outCtx.drawImage(
        hiddenCanvas,
        minX, minY, maxX - minX, maxY - minY,
        0, 0, w, h
      );
      
      outCtx.restore();
      
      return outCanvas.toDataURL('image/jpeg', 0.95);
    }
    
    function dist(a, b) { 
      return Math.hypot(a[0] - b[0], a[1] - b[1]); 
    }

    // === Feedback helpers ===
    function showStatus(msg, type = 'info') {
      statusBox.textContent = msg;
      statusBox.className = 'status ' + (type || '');
      if (type === 'success') setTimeout(() => statusBox.textContent = '', 3000);
    }

    // === Initialize ===
    window.onload = () => {
      console.log('Starting camera...');
      debugInfo.textContent = 'Starting...';
      startCamera();
    };
    
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
      } else if (!document.hidden && !video.srcObject) {
        startCamera();
      }
    });
  </script>
</body>
</html>
